# Copyright 2024 Miguel Matey Sanz
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

'''
Defines a model to manage the reports generated by the machine and deep learning models.
'''

from enum import Enum
from dataclasses import dataclass


class CustomEnum(Enum):
    def __str__(self):
        return str(self.value)    


class Model(CustomEnum):
    '''
    Enumeration to represent the ML and DL models. Values: MLP, CNN, LSTM, CNN_LSTM.
    '''

    MLP = 'mlp' #'''Value for MLP model.'''
    CNN = 'cnn' #'''Value for CNN model.'''
    LSTM = 'lstm' #'''Value for LSTM model.'''
    CNN_LSTM = 'cnn-lstm' #'''Value for CNN-LSTM model.'''
    
    def __lt__(self, other):
        if self == other:
            return False
        
        return MODELS.index(self) < MODELS.index(other)
    
MODELS = [Model.MLP, Model.CNN, Model.LSTM, Model.CNN_LSTM]
    
class Source(CustomEnum):
    '''
    Enumeration to represent the data sources. Values: SP, SW, FUSED.
    '''

    SP = 'sp' #'''Value for smartphone data source.'''
    SW = 'sw' #'''Value for smartwatch data source.'''
    FUSED = 'fused' #'''Value for fused data source.'''
    
    
    
class TargetFilter(CustomEnum):
    '''
    Enumeration for each attribute of interest from the model reports. Values: MODEL, SEATED, STANDING_UP, WALKING, TURNING, SITTING_DOWN.
    '''

    MODEL = 'model' #'''Value for a model-wise performance metric.'''
    SEATED = 'SEATED' #'''Value for a `SEATED` activity performance metric.'''
    STANDING_UP = 'STANDING_UP' #'''Value for a `STANDING_UP` activity performance metric.'''
    WALKING = 'WALKING' #'''Value for a `WALKING` activity performance metric.'''
    TURNING = 'TURNING' #'''Value for a `TURNING` activity performance metric.'''
    SITTING_DOWN = 'SITTING_DOWN' #'''Value for a `SITTING_DOWN` activity performance metric.'''
    
    
    def __lt__(self, other):
        if self == other:
            return False
        
        return ORDER.index(self) < ORDER.index(other)

ORDER = [TargetFilter.MODEL, TargetFilter.SEATED, TargetFilter.STANDING_UP, TargetFilter.WALKING, TargetFilter.TURNING, TargetFilter.SITTING_DOWN]
    

class ActivityMetric(CustomEnum):
    '''
    Enumeration for each metric of interest from the model reports for individual activities. Values: PRECISION, RECALL, F1, SUPPORT.
    '''

    PRECISION = 'precision' #'''Value for the precision metric.'''
    RECALL = 'recall' #'''Value for the recall metric.'''
    F1 = 'f1-score' #'''Value for the f1-score metric.'''
    SUPPORT = 'support' #'''Value for the support metric.'''
    
    
class ModelMetric(CustomEnum):
    '''
    Enumeration for each metric of interest from the model reports. Values: ACCURACY, TRAINING_TIME.
    '''

    ACCURACY = 'accuracy' #'''Value for the overall accuracy metric.'''
    TRAINING_TIME = 'training time' #'''Value for the training time metric.'''
    

@dataclass
class Filter:
    '''
    Class to represent a filter that can be applied to a dataframe of reports

    Attributes:
        model (str): Model to look for. One of `libs.chapter3.model.Model`
        source (str): Source to look for. One of `libs.chapter3.model.Source`
        target (str): Target to look for. One of `libs.chapter3.model.TargetFilter`.
        metric (str): Metric to look for. One of `libs.chapter3.model.ModelMetric` or `libs.chapter3.model.ActivityMetric`
    '''

    model: str
    source: str
    target: str
    metric: str
    
    def apply(self, df):
        '''
        Function to apply the filter to a specified dataframe.

        Args:
            df (`pandas.DataFrame`): Model reports.

        Returns:
            (`pandas.DataFrame`): Filtered model reports.
        '''

        if self.model is not None:
            df = df[df.model == str(self.model)]
        if self.source is not None:
            df = df[df.source == str(self.source)]
        if self.target is not None:
            df = df[df.target == str(self.target)]
        if self.metric is not None:
            df = df[df.metric == str(self.metric)]
        #return df[(df.target == str(self.target)) & (df.metric == str(self.metric))]
        return df