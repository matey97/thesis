'''
Defines a model to manage the reports generated by the machine and deep learning models.
'''

import numpy as np

from enum import Enum
from dataclasses import dataclass


class CustomEnum(Enum):
    def __str__(self):
        return str(self.value)    


class Model(CustomEnum):
    '''
    Enumeration to represent the ML and DL models. Values: MLP, CNN, LSTM, CNN_LSTM.
    '''

    MLP = 'mlp' #'''Value for MLP model.'''
    CNN = 'cnn' #'''Value for CNN model.'''
    LSTM = 'lstm' #'''Value for LSTM model.'''
    CNN_LSTM = 'cnn-lstm' #'''Value for CNN-LSTM model.'''
    
    def __lt__(self, other):
        if self == other:
            return False
        
        return MODELS.index(self) < MODELS.index(other)
    
MODELS = [Model.MLP, Model.CNN, Model.LSTM, Model.CNN_LSTM]
    
class Source(CustomEnum):
    '''
    Enumeration to represent the data sources. Values: SP, SW, FUSED.
    '''

    SP = 'sp' #'''Value for smartphone data source.'''
    SW = 'sw' #'''Value for smartwatch data source.'''
    FUSED = 'fused' #'''Value for fused data source.'''
    
    
    
class TargetFilter(CustomEnum):
    '''
    Enumeration for each attribute of interest from the model reports. Values: MODEL, SEATED, STANDING_UP, WALKING, TURNING, SITTING_DOWN.
    '''

    MODEL = 'model' #'''Value for a model-wise performance metric.'''
    SEATED = 'SEATED' #'''Value for a `SEATED` activity performance metric.'''
    STANDING_UP = 'STANDING_UP' #'''Value for a `STANDING_UP` activity performance metric.'''
    WALKING = 'WALKING' #'''Value for a `WALKING` activity performance metric.'''
    TURNING = 'TURNING' #'''Value for a `TURNING` activity performance metric.'''
    SITTING_DOWN = 'SITTING_DOWN' #'''Value for a `SITTING_DOWN` activity performance metric.'''
    
    
    def __lt__(self, other):
        if self == other:
            return False
        
        return ORDER.index(self) < ORDER.index(other)

ORDER = [TargetFilter.MODEL, TargetFilter.SEATED, TargetFilter.STANDING_UP, TargetFilter.WALKING, TargetFilter.TURNING, TargetFilter.SITTING_DOWN]
    

class ActivityMetric(CustomEnum):
    '''
    Enumeration for each metric of interest from the model reports for individual activities. Values: PRECISION, RECALL, F1, SUPPORT.
    '''

    PRECISION = 'precision' #'''Value for the precision metric.'''
    RECALL = 'recall' #'''Value for the recall metric.'''
    F1 = 'f1-score' #'''Value for the f1-score metric.'''
    SUPPORT = 'support' #'''Value for the support metric.'''
    
    
class ModelMetric(CustomEnum):
    '''
    Enumeration for each metric of interest from the model reports. Values: ACCURACY, TRAINING_TIME.
    '''

    ACCURACY = 'accuracy' #'''Value for the overall accuracy metric.'''
    TRAINING_TIME = 'training time' #'''Value for the training time metric.'''
    

@dataclass
class Filter:
    '''
    Class to represent a filter that can be applied to a dataframe of reports

    Attributes:
        model (str): Model to look for. One of `libs.chapter3.model.Model`
        source (str): Source to look for. One of `libs.chapter3.model.Source`
        target (str): Target to look for. One of `libs.chapter3.model.TargetFilter`.
        metric (str): Metric to look for. One of `libs.chapter3.model.ModelMetric` or `libs.chapter3.model.ActivityMetric`
    '''

    model: str
    source: str
    target: str
    metric: str
    
    def apply(self, df):
        '''
        Function to apply the filter to a specified dataframe.

        Args:
            df (`pandas.DataFrame`): Model reports.

        Returns:
            (`pandas.DataFrame`): Filtered model reports.
        '''

        if self.model is not None:
            df = df[df.model == str(self.model)]
        if self.source is not None:
            df = df[df.source == str(self.source)]
        if self.target is not None:
            df = df[df.target == str(self.target)]
        if self.metric is not None:
            df = df[df.metric == str(self.metric)]
        #return df[(df.target == str(self.target)) & (df.metric == str(self.metric))]
        return df
    

def obtain_best_items(test_results, focus_on, groups):
    '''
    Determines the best performant item (model or data source) from a DataFrame of statistical tests comparing groups.

    Args:
        test_results (`pandas.DataFrame`): DataFrame with statistical tests. Generated with `libs.chapter3.statistical_tests.statistical_comparison`.
        focus_on (list[str]): Items being compared. List items are one of `libs.chapter3.model.Source` or `libs.chapter3.model.Model`.
        groups (list[str]): Each group where `focus_on` items are compared. List items are one of `libs.chapter3.model.Source` or `libs.chapter3.model.Model`.

    Returns:
        (dict): Dict containing the best performant item.
    '''

    bests = {}
    for target, tests in test_results.items():
        bests[target] = {}
        for group in groups:
            group_df = tests[group][[str(item) for item in focus_on]]
            ordered = group_df.to_numpy().argsort()
            ordered = np.flip(ordered, axis=1)
            bests[target][group] = ordered
    return bests